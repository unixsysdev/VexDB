// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: vxdb.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	StorageService_InsertVector_FullMethodName        = "/vxdb.StorageService/InsertVector"
	StorageService_InsertVectorStream_FullMethodName  = "/vxdb.StorageService/InsertVectorStream"
	StorageService_Search_FullMethodName              = "/vxdb.StorageService/Search"
	StorageService_SearchStream_FullMethodName        = "/vxdb.StorageService/SearchStream"
	StorageService_DeleteVectors_FullMethodName       = "/vxdb.StorageService/DeleteVectors"
	StorageService_DeleteVectorsStream_FullMethodName = "/vxdb.StorageService/DeleteVectorsStream"
	StorageService_GetClusterInfo_FullMethodName      = "/vxdb.StorageService/GetClusterInfo"
	StorageService_GetClusterStatus_FullMethodName    = "/vxdb.StorageService/GetClusterStatus"
	StorageService_HealthCheck_FullMethodName         = "/vxdb.StorageService/HealthCheck"
	StorageService_GetMetrics_FullMethodName          = "/vxdb.StorageService/GetMetrics"
	StorageService_UpdateConfig_FullMethodName        = "/vxdb.StorageService/UpdateConfig"
	StorageService_GetConfig_FullMethodName           = "/vxdb.StorageService/GetConfig"
)

// StorageServiceClient is the client API for StorageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// StorageService provides storage operations
type StorageServiceClient interface {
	// Insert operations
	InsertVector(ctx context.Context, in *InsertRequest, opts ...grpc.CallOption) (*InsertResponse, error)
	InsertVectorStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[InsertRequest, InsertResponse], error)
	// Search operations
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	SearchStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SearchRequest, SearchResponse], error)
	// Delete operations
	DeleteVectors(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	DeleteVectorsStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[DeleteRequest, DeleteResponse], error)
	// Cluster management
	GetClusterInfo(ctx context.Context, in *ClusterInfo, opts ...grpc.CallOption) (*ClusterInfo, error)
	GetClusterStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClusterStatus, error)
	// Health and metrics
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	GetMetrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*MetricsResponse, error)
	// Configuration
	UpdateConfig(ctx context.Context, in *ConfigUpdateRequest, opts ...grpc.CallOption) (*ConfigUpdateResponse, error)
	GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConfigUpdateResponse, error)
}

type storageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStorageServiceClient(cc grpc.ClientConnInterface) StorageServiceClient {
	return &storageServiceClient{cc}
}

func (c *storageServiceClient) InsertVector(ctx context.Context, in *InsertRequest, opts ...grpc.CallOption) (*InsertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InsertResponse)
	err := c.cc.Invoke(ctx, StorageService_InsertVector_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageServiceClient) InsertVectorStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[InsertRequest, InsertResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &StorageService_ServiceDesc.Streams[0], StorageService_InsertVectorStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[InsertRequest, InsertResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StorageService_InsertVectorStreamClient = grpc.BidiStreamingClient[InsertRequest, InsertResponse]

func (c *storageServiceClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, StorageService_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageServiceClient) SearchStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SearchRequest, SearchResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &StorageService_ServiceDesc.Streams[1], StorageService_SearchStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SearchRequest, SearchResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StorageService_SearchStreamClient = grpc.BidiStreamingClient[SearchRequest, SearchResponse]

func (c *storageServiceClient) DeleteVectors(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, StorageService_DeleteVectors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageServiceClient) DeleteVectorsStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[DeleteRequest, DeleteResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &StorageService_ServiceDesc.Streams[2], StorageService_DeleteVectorsStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DeleteRequest, DeleteResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StorageService_DeleteVectorsStreamClient = grpc.BidiStreamingClient[DeleteRequest, DeleteResponse]

func (c *storageServiceClient) GetClusterInfo(ctx context.Context, in *ClusterInfo, opts ...grpc.CallOption) (*ClusterInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterInfo)
	err := c.cc.Invoke(ctx, StorageService_GetClusterInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageServiceClient) GetClusterStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClusterStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterStatus)
	err := c.cc.Invoke(ctx, StorageService_GetClusterStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, StorageService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageServiceClient) GetMetrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*MetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MetricsResponse)
	err := c.cc.Invoke(ctx, StorageService_GetMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageServiceClient) UpdateConfig(ctx context.Context, in *ConfigUpdateRequest, opts ...grpc.CallOption) (*ConfigUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigUpdateResponse)
	err := c.cc.Invoke(ctx, StorageService_UpdateConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageServiceClient) GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConfigUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigUpdateResponse)
	err := c.cc.Invoke(ctx, StorageService_GetConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StorageServiceServer is the server API for StorageService service.
// All implementations must embed UnimplementedStorageServiceServer
// for forward compatibility.
//
// StorageService provides storage operations
type StorageServiceServer interface {
	// Insert operations
	InsertVector(context.Context, *InsertRequest) (*InsertResponse, error)
	InsertVectorStream(grpc.BidiStreamingServer[InsertRequest, InsertResponse]) error
	// Search operations
	Search(context.Context, *SearchRequest) (*SearchResponse, error)
	SearchStream(grpc.BidiStreamingServer[SearchRequest, SearchResponse]) error
	// Delete operations
	DeleteVectors(context.Context, *DeleteRequest) (*DeleteResponse, error)
	DeleteVectorsStream(grpc.BidiStreamingServer[DeleteRequest, DeleteResponse]) error
	// Cluster management
	GetClusterInfo(context.Context, *ClusterInfo) (*ClusterInfo, error)
	GetClusterStatus(context.Context, *emptypb.Empty) (*ClusterStatus, error)
	// Health and metrics
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	GetMetrics(context.Context, *MetricsRequest) (*MetricsResponse, error)
	// Configuration
	UpdateConfig(context.Context, *ConfigUpdateRequest) (*ConfigUpdateResponse, error)
	GetConfig(context.Context, *emptypb.Empty) (*ConfigUpdateResponse, error)
	mustEmbedUnimplementedStorageServiceServer()
}

// UnimplementedStorageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStorageServiceServer struct{}

func (UnimplementedStorageServiceServer) InsertVector(context.Context, *InsertRequest) (*InsertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertVector not implemented")
}
func (UnimplementedStorageServiceServer) InsertVectorStream(grpc.BidiStreamingServer[InsertRequest, InsertResponse]) error {
	return status.Errorf(codes.Unimplemented, "method InsertVectorStream not implemented")
}
func (UnimplementedStorageServiceServer) Search(context.Context, *SearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedStorageServiceServer) SearchStream(grpc.BidiStreamingServer[SearchRequest, SearchResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SearchStream not implemented")
}
func (UnimplementedStorageServiceServer) DeleteVectors(context.Context, *DeleteRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVectors not implemented")
}
func (UnimplementedStorageServiceServer) DeleteVectorsStream(grpc.BidiStreamingServer[DeleteRequest, DeleteResponse]) error {
	return status.Errorf(codes.Unimplemented, "method DeleteVectorsStream not implemented")
}
func (UnimplementedStorageServiceServer) GetClusterInfo(context.Context, *ClusterInfo) (*ClusterInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterInfo not implemented")
}
func (UnimplementedStorageServiceServer) GetClusterStatus(context.Context, *emptypb.Empty) (*ClusterStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterStatus not implemented")
}
func (UnimplementedStorageServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedStorageServiceServer) GetMetrics(context.Context, *MetricsRequest) (*MetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetrics not implemented")
}
func (UnimplementedStorageServiceServer) UpdateConfig(context.Context, *ConfigUpdateRequest) (*ConfigUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateConfig not implemented")
}
func (UnimplementedStorageServiceServer) GetConfig(context.Context, *emptypb.Empty) (*ConfigUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfig not implemented")
}
func (UnimplementedStorageServiceServer) mustEmbedUnimplementedStorageServiceServer() {}
func (UnimplementedStorageServiceServer) testEmbeddedByValue()                        {}

// UnsafeStorageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StorageServiceServer will
// result in compilation errors.
type UnsafeStorageServiceServer interface {
	mustEmbedUnimplementedStorageServiceServer()
}

func RegisterStorageServiceServer(s grpc.ServiceRegistrar, srv StorageServiceServer) {
	// If the following call pancis, it indicates UnimplementedStorageServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StorageService_ServiceDesc, srv)
}

func _StorageService_InsertVector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServiceServer).InsertVector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageService_InsertVector_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServiceServer).InsertVector(ctx, req.(*InsertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageService_InsertVectorStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StorageServiceServer).InsertVectorStream(&grpc.GenericServerStream[InsertRequest, InsertResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StorageService_InsertVectorStreamServer = grpc.BidiStreamingServer[InsertRequest, InsertResponse]

func _StorageService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageService_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServiceServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageService_SearchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StorageServiceServer).SearchStream(&grpc.GenericServerStream[SearchRequest, SearchResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StorageService_SearchStreamServer = grpc.BidiStreamingServer[SearchRequest, SearchResponse]

func _StorageService_DeleteVectors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServiceServer).DeleteVectors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageService_DeleteVectors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServiceServer).DeleteVectors(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageService_DeleteVectorsStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StorageServiceServer).DeleteVectorsStream(&grpc.GenericServerStream[DeleteRequest, DeleteResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StorageService_DeleteVectorsStreamServer = grpc.BidiStreamingServer[DeleteRequest, DeleteResponse]

func _StorageService_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServiceServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageService_GetClusterInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServiceServer).GetClusterInfo(ctx, req.(*ClusterInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageService_GetClusterStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServiceServer).GetClusterStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageService_GetClusterStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServiceServer).GetClusterStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageService_GetMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServiceServer).GetMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageService_GetMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServiceServer).GetMetrics(ctx, req.(*MetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageService_UpdateConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServiceServer).UpdateConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageService_UpdateConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServiceServer).UpdateConfig(ctx, req.(*ConfigUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageService_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServiceServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageService_GetConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServiceServer).GetConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// StorageService_ServiceDesc is the grpc.ServiceDesc for StorageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StorageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vxdb.StorageService",
	HandlerType: (*StorageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InsertVector",
			Handler:    _StorageService_InsertVector_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _StorageService_Search_Handler,
		},
		{
			MethodName: "DeleteVectors",
			Handler:    _StorageService_DeleteVectors_Handler,
		},
		{
			MethodName: "GetClusterInfo",
			Handler:    _StorageService_GetClusterInfo_Handler,
		},
		{
			MethodName: "GetClusterStatus",
			Handler:    _StorageService_GetClusterStatus_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _StorageService_HealthCheck_Handler,
		},
		{
			MethodName: "GetMetrics",
			Handler:    _StorageService_GetMetrics_Handler,
		},
		{
			MethodName: "UpdateConfig",
			Handler:    _StorageService_UpdateConfig_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _StorageService_GetConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "InsertVectorStream",
			Handler:       _StorageService_InsertVectorStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SearchStream",
			Handler:       _StorageService_SearchStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DeleteVectorsStream",
			Handler:       _StorageService_DeleteVectorsStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "vxdb.proto",
}

const (
	InsertService_InsertVector_FullMethodName        = "/vxdb.InsertService/InsertVector"
	InsertService_InsertVectorStream_FullMethodName  = "/vxdb.InsertService/InsertVectorStream"
	InsertService_InsertBatch_FullMethodName         = "/vxdb.InsertService/InsertBatch"
	InsertService_InsertBatchStream_FullMethodName   = "/vxdb.InsertService/InsertBatchStream"
	InsertService_GetClusterForVector_FullMethodName = "/vxdb.InsertService/GetClusterForVector"
	InsertService_GetClusterStatus_FullMethodName    = "/vxdb.InsertService/GetClusterStatus"
	InsertService_HealthCheck_FullMethodName         = "/vxdb.InsertService/HealthCheck"
	InsertService_GetMetrics_FullMethodName          = "/vxdb.InsertService/GetMetrics"
	InsertService_UpdateConfig_FullMethodName        = "/vxdb.InsertService/UpdateConfig"
	InsertService_GetConfig_FullMethodName           = "/vxdb.InsertService/GetConfig"
)

// InsertServiceClient is the client API for InsertService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// InsertService provides vector insertion operations
type InsertServiceClient interface {
	// Insert operations
	InsertVector(ctx context.Context, in *InsertRequest, opts ...grpc.CallOption) (*InsertResponse, error)
	InsertVectorStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[InsertRequest, InsertResponse], error)
	// Batch operations
	InsertBatch(ctx context.Context, in *VectorBatch, opts ...grpc.CallOption) (*InsertResponse, error)
	InsertBatchStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[VectorBatch, InsertResponse], error)
	// Routing and cluster management
	GetClusterForVector(ctx context.Context, in *Vector, opts ...grpc.CallOption) (*ClusterInfo, error)
	GetClusterStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClusterStatus, error)
	// Health and metrics
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	GetMetrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*MetricsResponse, error)
	// Configuration
	UpdateConfig(ctx context.Context, in *ConfigUpdateRequest, opts ...grpc.CallOption) (*ConfigUpdateResponse, error)
	GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConfigUpdateResponse, error)
}

type insertServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInsertServiceClient(cc grpc.ClientConnInterface) InsertServiceClient {
	return &insertServiceClient{cc}
}

func (c *insertServiceClient) InsertVector(ctx context.Context, in *InsertRequest, opts ...grpc.CallOption) (*InsertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InsertResponse)
	err := c.cc.Invoke(ctx, InsertService_InsertVector_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *insertServiceClient) InsertVectorStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[InsertRequest, InsertResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &InsertService_ServiceDesc.Streams[0], InsertService_InsertVectorStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[InsertRequest, InsertResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type InsertService_InsertVectorStreamClient = grpc.BidiStreamingClient[InsertRequest, InsertResponse]

func (c *insertServiceClient) InsertBatch(ctx context.Context, in *VectorBatch, opts ...grpc.CallOption) (*InsertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InsertResponse)
	err := c.cc.Invoke(ctx, InsertService_InsertBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *insertServiceClient) InsertBatchStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[VectorBatch, InsertResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &InsertService_ServiceDesc.Streams[1], InsertService_InsertBatchStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[VectorBatch, InsertResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type InsertService_InsertBatchStreamClient = grpc.BidiStreamingClient[VectorBatch, InsertResponse]

func (c *insertServiceClient) GetClusterForVector(ctx context.Context, in *Vector, opts ...grpc.CallOption) (*ClusterInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterInfo)
	err := c.cc.Invoke(ctx, InsertService_GetClusterForVector_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *insertServiceClient) GetClusterStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClusterStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterStatus)
	err := c.cc.Invoke(ctx, InsertService_GetClusterStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *insertServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, InsertService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *insertServiceClient) GetMetrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*MetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MetricsResponse)
	err := c.cc.Invoke(ctx, InsertService_GetMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *insertServiceClient) UpdateConfig(ctx context.Context, in *ConfigUpdateRequest, opts ...grpc.CallOption) (*ConfigUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigUpdateResponse)
	err := c.cc.Invoke(ctx, InsertService_UpdateConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *insertServiceClient) GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConfigUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigUpdateResponse)
	err := c.cc.Invoke(ctx, InsertService_GetConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InsertServiceServer is the server API for InsertService service.
// All implementations must embed UnimplementedInsertServiceServer
// for forward compatibility.
//
// InsertService provides vector insertion operations
type InsertServiceServer interface {
	// Insert operations
	InsertVector(context.Context, *InsertRequest) (*InsertResponse, error)
	InsertVectorStream(grpc.BidiStreamingServer[InsertRequest, InsertResponse]) error
	// Batch operations
	InsertBatch(context.Context, *VectorBatch) (*InsertResponse, error)
	InsertBatchStream(grpc.BidiStreamingServer[VectorBatch, InsertResponse]) error
	// Routing and cluster management
	GetClusterForVector(context.Context, *Vector) (*ClusterInfo, error)
	GetClusterStatus(context.Context, *emptypb.Empty) (*ClusterStatus, error)
	// Health and metrics
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	GetMetrics(context.Context, *MetricsRequest) (*MetricsResponse, error)
	// Configuration
	UpdateConfig(context.Context, *ConfigUpdateRequest) (*ConfigUpdateResponse, error)
	GetConfig(context.Context, *emptypb.Empty) (*ConfigUpdateResponse, error)
	mustEmbedUnimplementedInsertServiceServer()
}

// UnimplementedInsertServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInsertServiceServer struct{}

func (UnimplementedInsertServiceServer) InsertVector(context.Context, *InsertRequest) (*InsertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertVector not implemented")
}
func (UnimplementedInsertServiceServer) InsertVectorStream(grpc.BidiStreamingServer[InsertRequest, InsertResponse]) error {
	return status.Errorf(codes.Unimplemented, "method InsertVectorStream not implemented")
}
func (UnimplementedInsertServiceServer) InsertBatch(context.Context, *VectorBatch) (*InsertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertBatch not implemented")
}
func (UnimplementedInsertServiceServer) InsertBatchStream(grpc.BidiStreamingServer[VectorBatch, InsertResponse]) error {
	return status.Errorf(codes.Unimplemented, "method InsertBatchStream not implemented")
}
func (UnimplementedInsertServiceServer) GetClusterForVector(context.Context, *Vector) (*ClusterInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterForVector not implemented")
}
func (UnimplementedInsertServiceServer) GetClusterStatus(context.Context, *emptypb.Empty) (*ClusterStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterStatus not implemented")
}
func (UnimplementedInsertServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedInsertServiceServer) GetMetrics(context.Context, *MetricsRequest) (*MetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetrics not implemented")
}
func (UnimplementedInsertServiceServer) UpdateConfig(context.Context, *ConfigUpdateRequest) (*ConfigUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateConfig not implemented")
}
func (UnimplementedInsertServiceServer) GetConfig(context.Context, *emptypb.Empty) (*ConfigUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfig not implemented")
}
func (UnimplementedInsertServiceServer) mustEmbedUnimplementedInsertServiceServer() {}
func (UnimplementedInsertServiceServer) testEmbeddedByValue()                       {}

// UnsafeInsertServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InsertServiceServer will
// result in compilation errors.
type UnsafeInsertServiceServer interface {
	mustEmbedUnimplementedInsertServiceServer()
}

func RegisterInsertServiceServer(s grpc.ServiceRegistrar, srv InsertServiceServer) {
	// If the following call pancis, it indicates UnimplementedInsertServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&InsertService_ServiceDesc, srv)
}

func _InsertService_InsertVector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InsertServiceServer).InsertVector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InsertService_InsertVector_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InsertServiceServer).InsertVector(ctx, req.(*InsertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InsertService_InsertVectorStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InsertServiceServer).InsertVectorStream(&grpc.GenericServerStream[InsertRequest, InsertResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type InsertService_InsertVectorStreamServer = grpc.BidiStreamingServer[InsertRequest, InsertResponse]

func _InsertService_InsertBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VectorBatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InsertServiceServer).InsertBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InsertService_InsertBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InsertServiceServer).InsertBatch(ctx, req.(*VectorBatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _InsertService_InsertBatchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InsertServiceServer).InsertBatchStream(&grpc.GenericServerStream[VectorBatch, InsertResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type InsertService_InsertBatchStreamServer = grpc.BidiStreamingServer[VectorBatch, InsertResponse]

func _InsertService_GetClusterForVector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Vector)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InsertServiceServer).GetClusterForVector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InsertService_GetClusterForVector_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InsertServiceServer).GetClusterForVector(ctx, req.(*Vector))
	}
	return interceptor(ctx, in, info, handler)
}

func _InsertService_GetClusterStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InsertServiceServer).GetClusterStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InsertService_GetClusterStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InsertServiceServer).GetClusterStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _InsertService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InsertServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InsertService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InsertServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InsertService_GetMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InsertServiceServer).GetMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InsertService_GetMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InsertServiceServer).GetMetrics(ctx, req.(*MetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InsertService_UpdateConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InsertServiceServer).UpdateConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InsertService_UpdateConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InsertServiceServer).UpdateConfig(ctx, req.(*ConfigUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InsertService_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InsertServiceServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InsertService_GetConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InsertServiceServer).GetConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// InsertService_ServiceDesc is the grpc.ServiceDesc for InsertService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InsertService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vxdb.InsertService",
	HandlerType: (*InsertServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InsertVector",
			Handler:    _InsertService_InsertVector_Handler,
		},
		{
			MethodName: "InsertBatch",
			Handler:    _InsertService_InsertBatch_Handler,
		},
		{
			MethodName: "GetClusterForVector",
			Handler:    _InsertService_GetClusterForVector_Handler,
		},
		{
			MethodName: "GetClusterStatus",
			Handler:    _InsertService_GetClusterStatus_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _InsertService_HealthCheck_Handler,
		},
		{
			MethodName: "GetMetrics",
			Handler:    _InsertService_GetMetrics_Handler,
		},
		{
			MethodName: "UpdateConfig",
			Handler:    _InsertService_UpdateConfig_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _InsertService_GetConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "InsertVectorStream",
			Handler:       _InsertService_InsertVectorStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "InsertBatchStream",
			Handler:       _InsertService_InsertBatchStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "vxdb.proto",
}

const (
	SearchService_Search_FullMethodName                   = "/vxdb.SearchService/Search"
	SearchService_SearchStream_FullMethodName             = "/vxdb.SearchService/SearchStream"
	SearchService_MultiClusterSearch_FullMethodName       = "/vxdb.SearchService/MultiClusterSearch"
	SearchService_MultiClusterSearchStream_FullMethodName = "/vxdb.SearchService/MultiClusterSearchStream"
	SearchService_GetClusterInfo_FullMethodName           = "/vxdb.SearchService/GetClusterInfo"
	SearchService_GetClusterStatus_FullMethodName         = "/vxdb.SearchService/GetClusterStatus"
	SearchService_HealthCheck_FullMethodName              = "/vxdb.SearchService/HealthCheck"
	SearchService_GetMetrics_FullMethodName               = "/vxdb.SearchService/GetMetrics"
	SearchService_UpdateConfig_FullMethodName             = "/vxdb.SearchService/UpdateConfig"
	SearchService_GetConfig_FullMethodName                = "/vxdb.SearchService/GetConfig"
)

// SearchServiceClient is the client API for SearchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// SearchService provides search operations
type SearchServiceClient interface {
	// Search operations
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	SearchStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SearchRequest, SearchResponse], error)
	// Multi-cluster search
	MultiClusterSearch(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	MultiClusterSearchStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SearchRequest, SearchResponse], error)
	// Cluster management
	GetClusterInfo(ctx context.Context, in *ClusterInfo, opts ...grpc.CallOption) (*ClusterInfo, error)
	GetClusterStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClusterStatus, error)
	// Health and metrics
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	GetMetrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*MetricsResponse, error)
	// Configuration
	UpdateConfig(ctx context.Context, in *ConfigUpdateRequest, opts ...grpc.CallOption) (*ConfigUpdateResponse, error)
	GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConfigUpdateResponse, error)
}

type searchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSearchServiceClient(cc grpc.ClientConnInterface) SearchServiceClient {
	return &searchServiceClient{cc}
}

func (c *searchServiceClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, SearchService_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) SearchStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SearchRequest, SearchResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SearchService_ServiceDesc.Streams[0], SearchService_SearchStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SearchRequest, SearchResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SearchService_SearchStreamClient = grpc.BidiStreamingClient[SearchRequest, SearchResponse]

func (c *searchServiceClient) MultiClusterSearch(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, SearchService_MultiClusterSearch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) MultiClusterSearchStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SearchRequest, SearchResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SearchService_ServiceDesc.Streams[1], SearchService_MultiClusterSearchStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SearchRequest, SearchResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SearchService_MultiClusterSearchStreamClient = grpc.BidiStreamingClient[SearchRequest, SearchResponse]

func (c *searchServiceClient) GetClusterInfo(ctx context.Context, in *ClusterInfo, opts ...grpc.CallOption) (*ClusterInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterInfo)
	err := c.cc.Invoke(ctx, SearchService_GetClusterInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) GetClusterStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClusterStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterStatus)
	err := c.cc.Invoke(ctx, SearchService_GetClusterStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, SearchService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) GetMetrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*MetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MetricsResponse)
	err := c.cc.Invoke(ctx, SearchService_GetMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) UpdateConfig(ctx context.Context, in *ConfigUpdateRequest, opts ...grpc.CallOption) (*ConfigUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigUpdateResponse)
	err := c.cc.Invoke(ctx, SearchService_UpdateConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConfigUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigUpdateResponse)
	err := c.cc.Invoke(ctx, SearchService_GetConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SearchServiceServer is the server API for SearchService service.
// All implementations must embed UnimplementedSearchServiceServer
// for forward compatibility.
//
// SearchService provides search operations
type SearchServiceServer interface {
	// Search operations
	Search(context.Context, *SearchRequest) (*SearchResponse, error)
	SearchStream(grpc.BidiStreamingServer[SearchRequest, SearchResponse]) error
	// Multi-cluster search
	MultiClusterSearch(context.Context, *SearchRequest) (*SearchResponse, error)
	MultiClusterSearchStream(grpc.BidiStreamingServer[SearchRequest, SearchResponse]) error
	// Cluster management
	GetClusterInfo(context.Context, *ClusterInfo) (*ClusterInfo, error)
	GetClusterStatus(context.Context, *emptypb.Empty) (*ClusterStatus, error)
	// Health and metrics
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	GetMetrics(context.Context, *MetricsRequest) (*MetricsResponse, error)
	// Configuration
	UpdateConfig(context.Context, *ConfigUpdateRequest) (*ConfigUpdateResponse, error)
	GetConfig(context.Context, *emptypb.Empty) (*ConfigUpdateResponse, error)
	mustEmbedUnimplementedSearchServiceServer()
}

// UnimplementedSearchServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSearchServiceServer struct{}

func (UnimplementedSearchServiceServer) Search(context.Context, *SearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedSearchServiceServer) SearchStream(grpc.BidiStreamingServer[SearchRequest, SearchResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SearchStream not implemented")
}
func (UnimplementedSearchServiceServer) MultiClusterSearch(context.Context, *SearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultiClusterSearch not implemented")
}
func (UnimplementedSearchServiceServer) MultiClusterSearchStream(grpc.BidiStreamingServer[SearchRequest, SearchResponse]) error {
	return status.Errorf(codes.Unimplemented, "method MultiClusterSearchStream not implemented")
}
func (UnimplementedSearchServiceServer) GetClusterInfo(context.Context, *ClusterInfo) (*ClusterInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterInfo not implemented")
}
func (UnimplementedSearchServiceServer) GetClusterStatus(context.Context, *emptypb.Empty) (*ClusterStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterStatus not implemented")
}
func (UnimplementedSearchServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedSearchServiceServer) GetMetrics(context.Context, *MetricsRequest) (*MetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetrics not implemented")
}
func (UnimplementedSearchServiceServer) UpdateConfig(context.Context, *ConfigUpdateRequest) (*ConfigUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateConfig not implemented")
}
func (UnimplementedSearchServiceServer) GetConfig(context.Context, *emptypb.Empty) (*ConfigUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfig not implemented")
}
func (UnimplementedSearchServiceServer) mustEmbedUnimplementedSearchServiceServer() {}
func (UnimplementedSearchServiceServer) testEmbeddedByValue()                       {}

// UnsafeSearchServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SearchServiceServer will
// result in compilation errors.
type UnsafeSearchServiceServer interface {
	mustEmbedUnimplementedSearchServiceServer()
}

func RegisterSearchServiceServer(s grpc.ServiceRegistrar, srv SearchServiceServer) {
	// If the following call pancis, it indicates UnimplementedSearchServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SearchService_ServiceDesc, srv)
}

func _SearchService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_SearchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SearchServiceServer).SearchStream(&grpc.GenericServerStream[SearchRequest, SearchResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SearchService_SearchStreamServer = grpc.BidiStreamingServer[SearchRequest, SearchResponse]

func _SearchService_MultiClusterSearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).MultiClusterSearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_MultiClusterSearch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).MultiClusterSearch(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_MultiClusterSearchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SearchServiceServer).MultiClusterSearchStream(&grpc.GenericServerStream[SearchRequest, SearchResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SearchService_MultiClusterSearchStreamServer = grpc.BidiStreamingServer[SearchRequest, SearchResponse]

func _SearchService_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_GetClusterInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).GetClusterInfo(ctx, req.(*ClusterInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_GetClusterStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).GetClusterStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_GetClusterStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).GetClusterStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_GetMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).GetMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_GetMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).GetMetrics(ctx, req.(*MetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_UpdateConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).UpdateConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_UpdateConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).UpdateConfig(ctx, req.(*ConfigUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_GetConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).GetConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// SearchService_ServiceDesc is the grpc.ServiceDesc for SearchService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SearchService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vxdb.SearchService",
	HandlerType: (*SearchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _SearchService_Search_Handler,
		},
		{
			MethodName: "MultiClusterSearch",
			Handler:    _SearchService_MultiClusterSearch_Handler,
		},
		{
			MethodName: "GetClusterInfo",
			Handler:    _SearchService_GetClusterInfo_Handler,
		},
		{
			MethodName: "GetClusterStatus",
			Handler:    _SearchService_GetClusterStatus_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _SearchService_HealthCheck_Handler,
		},
		{
			MethodName: "GetMetrics",
			Handler:    _SearchService_GetMetrics_Handler,
		},
		{
			MethodName: "UpdateConfig",
			Handler:    _SearchService_UpdateConfig_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _SearchService_GetConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchStream",
			Handler:       _SearchService_SearchStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "MultiClusterSearchStream",
			Handler:       _SearchService_MultiClusterSearchStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "vxdb.proto",
}

const (
	AdminService_AddNode_FullMethodName        = "/vxdb.AdminService/AddNode"
	AdminService_RemoveNode_FullMethodName     = "/vxdb.AdminService/RemoveNode"
	AdminService_UpdateNode_FullMethodName     = "/vxdb.AdminService/UpdateNode"
	AdminService_CreateCluster_FullMethodName  = "/vxdb.AdminService/CreateCluster"
	AdminService_DeleteCluster_FullMethodName  = "/vxdb.AdminService/DeleteCluster"
	AdminService_UpdateCluster_FullMethodName  = "/vxdb.AdminService/UpdateCluster"
	AdminService_BackupSystem_FullMethodName   = "/vxdb.AdminService/BackupSystem"
	AdminService_RestoreSystem_FullMethodName  = "/vxdb.AdminService/RestoreSystem"
	AdminService_CompactStorage_FullMethodName = "/vxdb.AdminService/CompactStorage"
	AdminService_HealthCheck_FullMethodName    = "/vxdb.AdminService/HealthCheck"
	AdminService_GetMetrics_FullMethodName     = "/vxdb.AdminService/GetMetrics"
	AdminService_UpdateConfig_FullMethodName   = "/vxdb.AdminService/UpdateConfig"
	AdminService_GetConfig_FullMethodName      = "/vxdb.AdminService/GetConfig"
)

// AdminServiceClient is the client API for AdminService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// AdminService provides administrative operations
type AdminServiceClient interface {
	// Cluster management
	AddNode(ctx context.Context, in *NodeInfo, opts ...grpc.CallOption) (*NodeInfo, error)
	RemoveNode(ctx context.Context, in *NodeInfo, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateNode(ctx context.Context, in *NodeInfo, opts ...grpc.CallOption) (*NodeInfo, error)
	// Cluster operations
	CreateCluster(ctx context.Context, in *ClusterInfo, opts ...grpc.CallOption) (*ClusterInfo, error)
	DeleteCluster(ctx context.Context, in *ClusterInfo, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateCluster(ctx context.Context, in *ClusterInfo, opts ...grpc.CallOption) (*ClusterInfo, error)
	// System operations
	BackupSystem(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RestoreSystem(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CompactStorage(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Health and metrics
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	GetMetrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*MetricsResponse, error)
	// Configuration
	UpdateConfig(ctx context.Context, in *ConfigUpdateRequest, opts ...grpc.CallOption) (*ConfigUpdateResponse, error)
	GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConfigUpdateResponse, error)
}

type adminServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAdminServiceClient(cc grpc.ClientConnInterface) AdminServiceClient {
	return &adminServiceClient{cc}
}

func (c *adminServiceClient) AddNode(ctx context.Context, in *NodeInfo, opts ...grpc.CallOption) (*NodeInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeInfo)
	err := c.cc.Invoke(ctx, AdminService_AddNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) RemoveNode(ctx context.Context, in *NodeInfo, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AdminService_RemoveNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) UpdateNode(ctx context.Context, in *NodeInfo, opts ...grpc.CallOption) (*NodeInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeInfo)
	err := c.cc.Invoke(ctx, AdminService_UpdateNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) CreateCluster(ctx context.Context, in *ClusterInfo, opts ...grpc.CallOption) (*ClusterInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterInfo)
	err := c.cc.Invoke(ctx, AdminService_CreateCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) DeleteCluster(ctx context.Context, in *ClusterInfo, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AdminService_DeleteCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) UpdateCluster(ctx context.Context, in *ClusterInfo, opts ...grpc.CallOption) (*ClusterInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterInfo)
	err := c.cc.Invoke(ctx, AdminService_UpdateCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) BackupSystem(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AdminService_BackupSystem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) RestoreSystem(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AdminService_RestoreSystem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) CompactStorage(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AdminService_CompactStorage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, AdminService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetMetrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*MetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MetricsResponse)
	err := c.cc.Invoke(ctx, AdminService_GetMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) UpdateConfig(ctx context.Context, in *ConfigUpdateRequest, opts ...grpc.CallOption) (*ConfigUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigUpdateResponse)
	err := c.cc.Invoke(ctx, AdminService_UpdateConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ConfigUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigUpdateResponse)
	err := c.cc.Invoke(ctx, AdminService_GetConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdminServiceServer is the server API for AdminService service.
// All implementations must embed UnimplementedAdminServiceServer
// for forward compatibility.
//
// AdminService provides administrative operations
type AdminServiceServer interface {
	// Cluster management
	AddNode(context.Context, *NodeInfo) (*NodeInfo, error)
	RemoveNode(context.Context, *NodeInfo) (*emptypb.Empty, error)
	UpdateNode(context.Context, *NodeInfo) (*NodeInfo, error)
	// Cluster operations
	CreateCluster(context.Context, *ClusterInfo) (*ClusterInfo, error)
	DeleteCluster(context.Context, *ClusterInfo) (*emptypb.Empty, error)
	UpdateCluster(context.Context, *ClusterInfo) (*ClusterInfo, error)
	// System operations
	BackupSystem(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	RestoreSystem(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	CompactStorage(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// Health and metrics
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	GetMetrics(context.Context, *MetricsRequest) (*MetricsResponse, error)
	// Configuration
	UpdateConfig(context.Context, *ConfigUpdateRequest) (*ConfigUpdateResponse, error)
	GetConfig(context.Context, *emptypb.Empty) (*ConfigUpdateResponse, error)
	mustEmbedUnimplementedAdminServiceServer()
}

// UnimplementedAdminServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAdminServiceServer struct{}

func (UnimplementedAdminServiceServer) AddNode(context.Context, *NodeInfo) (*NodeInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddNode not implemented")
}
func (UnimplementedAdminServiceServer) RemoveNode(context.Context, *NodeInfo) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveNode not implemented")
}
func (UnimplementedAdminServiceServer) UpdateNode(context.Context, *NodeInfo) (*NodeInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNode not implemented")
}
func (UnimplementedAdminServiceServer) CreateCluster(context.Context, *ClusterInfo) (*ClusterInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCluster not implemented")
}
func (UnimplementedAdminServiceServer) DeleteCluster(context.Context, *ClusterInfo) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCluster not implemented")
}
func (UnimplementedAdminServiceServer) UpdateCluster(context.Context, *ClusterInfo) (*ClusterInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCluster not implemented")
}
func (UnimplementedAdminServiceServer) BackupSystem(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BackupSystem not implemented")
}
func (UnimplementedAdminServiceServer) RestoreSystem(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreSystem not implemented")
}
func (UnimplementedAdminServiceServer) CompactStorage(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompactStorage not implemented")
}
func (UnimplementedAdminServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedAdminServiceServer) GetMetrics(context.Context, *MetricsRequest) (*MetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetrics not implemented")
}
func (UnimplementedAdminServiceServer) UpdateConfig(context.Context, *ConfigUpdateRequest) (*ConfigUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateConfig not implemented")
}
func (UnimplementedAdminServiceServer) GetConfig(context.Context, *emptypb.Empty) (*ConfigUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfig not implemented")
}
func (UnimplementedAdminServiceServer) mustEmbedUnimplementedAdminServiceServer() {}
func (UnimplementedAdminServiceServer) testEmbeddedByValue()                      {}

// UnsafeAdminServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AdminServiceServer will
// result in compilation errors.
type UnsafeAdminServiceServer interface {
	mustEmbedUnimplementedAdminServiceServer()
}

func RegisterAdminServiceServer(s grpc.ServiceRegistrar, srv AdminServiceServer) {
	// If the following call pancis, it indicates UnimplementedAdminServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AdminService_ServiceDesc, srv)
}

func _AdminService_AddNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).AddNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_AddNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).AddNode(ctx, req.(*NodeInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_RemoveNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).RemoveNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_RemoveNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).RemoveNode(ctx, req.(*NodeInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_UpdateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).UpdateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_UpdateNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).UpdateNode(ctx, req.(*NodeInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_CreateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).CreateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_CreateCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).CreateCluster(ctx, req.(*ClusterInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_DeleteCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).DeleteCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_DeleteCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).DeleteCluster(ctx, req.(*ClusterInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_UpdateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).UpdateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_UpdateCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).UpdateCluster(ctx, req.(*ClusterInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_BackupSystem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).BackupSystem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_BackupSystem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).BackupSystem(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_RestoreSystem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).RestoreSystem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_RestoreSystem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).RestoreSystem(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_CompactStorage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).CompactStorage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_CompactStorage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).CompactStorage(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetMetrics(ctx, req.(*MetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_UpdateConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).UpdateConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_UpdateConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).UpdateConfig(ctx, req.(*ConfigUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// AdminService_ServiceDesc is the grpc.ServiceDesc for AdminService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AdminService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "vxdb.AdminService",
	HandlerType: (*AdminServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddNode",
			Handler:    _AdminService_AddNode_Handler,
		},
		{
			MethodName: "RemoveNode",
			Handler:    _AdminService_RemoveNode_Handler,
		},
		{
			MethodName: "UpdateNode",
			Handler:    _AdminService_UpdateNode_Handler,
		},
		{
			MethodName: "CreateCluster",
			Handler:    _AdminService_CreateCluster_Handler,
		},
		{
			MethodName: "DeleteCluster",
			Handler:    _AdminService_DeleteCluster_Handler,
		},
		{
			MethodName: "UpdateCluster",
			Handler:    _AdminService_UpdateCluster_Handler,
		},
		{
			MethodName: "BackupSystem",
			Handler:    _AdminService_BackupSystem_Handler,
		},
		{
			MethodName: "RestoreSystem",
			Handler:    _AdminService_RestoreSystem_Handler,
		},
		{
			MethodName: "CompactStorage",
			Handler:    _AdminService_CompactStorage_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _AdminService_HealthCheck_Handler,
		},
		{
			MethodName: "GetMetrics",
			Handler:    _AdminService_GetMetrics_Handler,
		},
		{
			MethodName: "UpdateConfig",
			Handler:    _AdminService_UpdateConfig_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _AdminService_GetConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vxdb.proto",
}
